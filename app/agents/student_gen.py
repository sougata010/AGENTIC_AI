import os
import asyncio
import json
import random
from typing import List, Dict, Optional, Any
from datetime import datetime, timedelta
from pydantic import BaseModel, Field
from langchain_google_genai import ChatGoogleGenerativeAI
from langchain_core.prompts import ChatPromptTemplate
from xhtml2pdf import pisa
from dotenv import load_dotenv

from app.agents.base import BaseAgent
from app.config import settings

# Ensure environment variables are loaded
load_dotenv()

# --- Configuration ---

DATA_DIR = settings.DATA_DIR / "student_data"
NOTES_DIR = DATA_DIR / "notes"
ROADMAPS_DIR = DATA_DIR / "roadmaps"
QUIZZES_DIR = DATA_DIR / "quizzes"
DSA_DIR = DATA_DIR / "dsa"
CODE_DIR = DATA_DIR / "code_reviews"

for d in [DATA_DIR, NOTES_DIR, ROADMAPS_DIR, QUIZZES_DIR, DSA_DIR, CODE_DIR]:
    os.makedirs(d, exist_ok=True)

# --- Pydantic Models ---

class Note(BaseModel):
    title: str
    topic: str
    summary: str
    key_points: List[str]
    detailed_content: str
    examples: List[str]
    practice_questions: List[str]

class RoadmapStep(BaseModel):
    step_number: int
    topic: str
    description: str
    resources: List[str]
    duration: str

class Roadmap(BaseModel):
    title: str
    target_audience: str
    steps: List[RoadmapStep]

class QuizQuestion(BaseModel):
    question: str
    options: List[str]
    correct_answer: str
    explanation: str

class Quiz(BaseModel):
    title: str
    difficulty: str
    questions: List[QuizQuestion]

class DifficultyLevel(str):
    EASY = "Easy"
    MEDIUM = "Medium"
    HARD = "Hard"

class DSAProblem(BaseModel):
    problem_name: str
    difficulty: str
    problem_statement: str
    examples: List[str]
    constraints: List[str]
    hints: List[str]
    solution_approach: str
    code_solution: str
    time_complexity: str
    space_complexity: str

class CodeReview(BaseModel):
    correctness: str
    efficiency: str
    style: str
    bugs: List[str]
    improvements: List[str]
    rating: int = Field(ge=1, le=10)

class InterviewQuestion(BaseModel):
    question: str
    topic: str
    difficulty: str
    expected_answer_points: List[str]
    tips: List[str]

class Step(BaseModel):
    step_number: int
    title: str
    explanation: str
    code_snippet: Optional[str] = None

class StepByStepGuide(BaseModel):
    topic: str
    steps: List[Step]
    summary: str

# --- PDF Generation Helper ---

CSS = """<style>
@page{size:A4;margin:2cm}body{font-family:Helvetica,Arial,sans-serif;font-size:11pt;line-height:1.6;color:#333}
h1{color:#2c3e50;border-bottom:2px solid #3498db;padding-bottom:10px}
h2{color:#2980b9;margin-top:20px}
.box{background:#f8f9fa;padding:15px;border-left:5px solid #3498db;margin:10px 0;border-radius:4px}
.code{background:#2d3436;color:#dfe6e9;padding:15px;font-family:monospace;border-radius:5px;white-space:pre-wrap}
.example{background:#e8f8f5;padding:10px;border-left:4px solid #1abc9c}
.question{background:#fff3e0;padding:10px;border-left:4px solid #f39c12;margin-bottom:15px}
.footer{font-size:8pt;color:#7f8c8d;text-align:center;margin-top:30px;border-top:1px solid #ccc;padding-top:10px}
</style>"""

def create_pdf(html: str, folder: str, filename: str) -> str:
    path = DATA_DIR / folder / f"{filename}_{datetime.now().strftime('%Y%m%d_%H%M%S')}.pdf"
    with open(path, "wb") as f:
        pisa.CreatePDF(CSS + html + f'<div class="footer">Generated by STUDENT GEN - {datetime.now()}</div>', dest=f)
    print(f"ðŸ“„ PDF Generated: {path}")
    return str(path)

# --- StudentGen Logic ---

class STUDENT_GEN:
    def __init__(self, agent):
        self.agent = agent
        self.model = agent.model
    
    async def generate_notes(self, topic: str) -> Dict[str, Any]:
        prompt = ChatPromptTemplate.from_messages([
            ("system", "You are an expert tutor. Create comprehensive study notes with examples and practice questions."),
            ("human", "Topic: {topic}")
        ])
        chain = prompt | self.model.with_structured_output(Note)
        note = await self.agent._safe_invoke(chain, {"topic": topic})
        
        html = f"""<h1>{note.title}</h1><div class="box"><strong>Summary:</strong> {note.summary}</div>
        <h2>Key Points</h2><ul>{''.join([f'<li>{p}</li>' for p in note.key_points])}</ul>
        <h2>Detailed Content</h2><p>{note.detailed_content}</p>
        <h2>Examples</h2>{''.join([f'<div class="example">{e}</div>' for e in note.examples])}
        <h2>Practice Questions</h2><ul>{''.join([f'<li>{q}</li>' for q in note.practice_questions])}</ul>"""
        
        pdf_path = await asyncio.to_thread(create_pdf, html, "notes", topic.replace(" ", "_"))
        return {"note": note.model_dump(), "pdf": pdf_path}

    async def generate_roadmap(self, topic: str) -> Dict[str, Any]:
        prompt = ChatPromptTemplate.from_messages([
            ("system", "You are a career counselor. Create a detailed learning roadmap."),
            ("human", "I want to learn: {topic}")
        ])
        chain = prompt | self.model.with_structured_output(Roadmap)
        roadmap = await self.agent._safe_invoke(chain, {"topic": topic})
        
        steps_html = ''.join([f"""<div class="box"><h3>Step {s.step_number}: {s.topic} ({s.duration})</h3>
        <p>{s.description}</p><p><strong>Resources:</strong> {', '.join(s.resources)}</p></div>""" for s in roadmap.steps])
        
        html = f"""<h1>{roadmap.title}</h1><p><strong>Audience:</strong> {roadmap.target_audience}</p>
        <h2>Learning Path</h2>{steps_html}"""
        
        pdf_path = await asyncio.to_thread(create_pdf, html, "roadmaps", topic.replace(" ", "_"))
        return {"roadmap": roadmap.model_dump(), "pdf": pdf_path}

    async def generate_quiz(self, topic: str, difficulty: str = "Medium") -> Dict[str, Any]:
        prompt = ChatPromptTemplate.from_messages([
            ("system", "You are a quiz master. Create a multiple-choice quiz."),
            ("human", "Topic: {topic}, Difficulty: {difficulty}")
        ])
        chain = prompt | self.model.with_structured_output(Quiz)
        quiz = await self.agent._safe_invoke(chain, {"topic": topic, "difficulty": difficulty})
        
        qs_html = ''.join([f"""<div class="question"><h3>Q{i+1}: {q.question}</h3>
        <ul>{''.join([f'<li>{o}</li>' for o in q.options])}</ul>
        <details><summary>Show Answer</summary><p><strong>Correct:</strong> {q.correct_answer}<br><em>{q.explanation}</em></p></details></div>""" for i, q in enumerate(quiz.questions)])
        
        html = f"""<h1>{quiz.title}</h1><h2>Difficulty: {quiz.difficulty}</h2>{qs_html}"""
        
        pdf_path = await asyncio.to_thread(create_pdf, html, "quizzes", topic.replace(" ", "_"))
        return {"quiz": quiz.model_dump(), "pdf": pdf_path}

    async def explain_algorithm(self, algo_name: str) -> Dict[str, Any]:
        return await self.generate_notes(f"Algorithm: {algo_name}") # Reusing notes for simplicity

    async def generate_dsa_problem(self, topic: str, difficulty: str) -> Dict[str, Any]:
        prompt = ChatPromptTemplate.from_messages([
            ("system", "You are a competitive programmer. Create a DSA problem with solution."),
            ("human", "Topic: {topic}, Difficulty: {difficulty}")
        ])
        chain = prompt | self.model.with_structured_output(DSAProblem)
        dsa = await self.agent._safe_invoke(chain, {"topic": topic, "difficulty": difficulty})
        
        html = f"""<h1>{dsa.problem_name}</h1><p><strong>Difficulty:</strong> {dsa.difficulty}</p>
        <h2>Problem Statement</h2><div class="box">{dsa.problem_statement}</div>
        <h2>Examples</h2><ul>{''.join([f'<li>{e}</li>' for e in dsa.examples])}</ul>
        <h2>Constraints</h2><ul>{''.join([f'<li>{c}</li>' for c in dsa.constraints])}</ul>
        <h2>Solution Approach</h2><p>{dsa.solution_approach}</p>
        <h2>Code Solution</h2><div class="code">{dsa.code_solution}</div>
        <p><strong>Time:</strong> {dsa.time_complexity} | <strong>Space:</strong> {dsa.space_complexity}</p>"""
        
        pdf_path = await asyncio.to_thread(create_pdf, html, "dsa", topic.replace(" ", "_"))
        return {"dsa": dsa.model_dump(), "pdf": pdf_path}

    async def debug_code(self, code: str, error: str = "") -> Dict[str, Any]:
        prompt = ChatPromptTemplate.from_messages([
            ("system", "You are a senior developer. Review this code, find bugs, and suggest improvements."),
            ("human", "Code:\n{code}\nError (if any): {error}")
        ])
        chain = prompt | self.model.with_structured_output(CodeReview)
        review = await self.agent._safe_invoke(chain, {"code": code, "error": error})
        
        html = f"""<h1>Code Review</h1><div class="score">Rating: {review.rating}/10</div>
        <h2>Correctness</h2><p>{review.correctness}</p>
        <h2>Bugs</h2><ul>{''.join([f'<li>{b}</li>' for b in review.bugs])}</ul>
        <h2>Improvements</h2><ul>{''.join([f'<li>{i}</li>' for i in review.improvements])}</ul>
        <h2>Efficiency</h2><p>{review.efficiency}</p>"""
        
        pdf_path = await asyncio.to_thread(create_pdf, html, "code_reviews", "review")
        return {"review": review.model_dump(), "pdf": pdf_path}

    async def mock_interview(self, topic: str) -> Dict[str, Any]:
        prompt = ChatPromptTemplate.from_messages([
            ("system", "You are a tech interviewer. Generate an interview question."),
            ("human", "Topic: {topic}")
        ])
        chain = prompt | self.model.with_structured_output(InterviewQuestion)
        q = await self.agent._safe_invoke(chain, {"topic": topic})
        html = f"""<h1>Mock Interview Question</h1>
        <h2>Topic: {q.topic}</h2>
        <div class="question"><h3>{q.question}</h3>
        <p><strong>Difficulty:</strong> {q.difficulty}</p>
        <details><summary>Tips</summary><ul>{''.join([f'<li>{t}</li>' for t in q.tips])}</ul></details>
        </div>
        """
        pdf_path = await asyncio.to_thread(create_pdf, html, "interviews", "mock_interview")
        return {"interview": q.model_dump(), "pdf": pdf_path}

    async def step_by_step(self, topic: str) -> Dict[str, Any]:
        prompt = ChatPromptTemplate.from_messages([
            ("system", "You are a teacher. Break down this topic into step-by-step instructions."),
            ("human", "Topic: {topic}")
        ])
        chain = prompt | self.model.with_structured_output(StepByStepGuide)
        guide = await self.agent._safe_invoke(chain, {"topic": topic})
        
        steps_html = ''.join([f"""<div class="box"><h3>Step {s.step_number}: {s.title}</h3>
        <p>{s.explanation}</p>{f'<div class="code">{s.code_snippet}</div>' if s.code_snippet else ''}</div>""" for s in guide.steps])
        
        html = f"""<h1>Guide: {guide.topic}</h1>{steps_html}
        <h2>Summary</h2><p>{guide.summary}</p>"""
        
        pdf_path = await asyncio.to_thread(create_pdf, html, "notes", f"guide_{topic.replace(' ', '_')}")
        return {"guide": guide.model_dump(), "pdf": pdf_path}

# --- Agent Core ---

class StudentGenAgent(BaseAgent):
    name = "student_gen"
    description = "AI Learning Assistant (Notes, Roadmaps, Quizzes, DSA, Code Help, Interviews)"
    icon = "ðŸŽ“"

    async def execute(self, topic: str, **kwargs) -> Dict[str, Any]:
        """
        Executes StudentGen operations.
        Args:
            topic: The main topic or input.
            kwargs:
                command (str): 'notes', 'roadmap', 'quiz', 'dsa', 'debug', 'interview', 'guide'
                difficulty (str): For quizzes/DSA
                code (str): For debugging
                error (str): For debugging
        """
        student = STUDENT_GEN(self)
        command = kwargs.get("command")
        
        if not command:
            return {"message": "Specify 'command' (e.g. command='notes')"}
        
        try:
            if command == 'notes': return await student.generate_notes(topic)
            elif command == 'roadmap': return await student.generate_roadmap(topic)
            elif command == 'quiz': return await student.generate_quiz(topic, kwargs.get('difficulty', 'Medium'))
            elif command == 'dsa': return await student.generate_dsa_problem(topic, kwargs.get('difficulty', 'Medium'))
            elif command == 'debug': return await student.debug_code(kwargs.get('code', topic), kwargs.get('error', ''))
            elif command == 'interview': return await student.mock_interview(topic)
            elif command == 'guide': return await student.step_by_step(topic)
            
            return {"error": f"Unknown command {command}"}
        except Exception as e:
            return {"error": str(e)}
